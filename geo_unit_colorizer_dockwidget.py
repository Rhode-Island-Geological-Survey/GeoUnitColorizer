# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeoUnitColorizerDockWidget
                                 A QGIS plugin
 Color geologic units
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-05-16
        git sha              : $Format:%H$
        copyright            : (C) 2025 by savage13
        email                : savage@uri.edu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import json
from pathlib import Path
import math

from qgis.utils import iface

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.core import QgsMessageLog, Qgis, QgsProject, QgsRenderContext, QgsFillSymbol
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QVBoxLayout, QScrollArea, QWidget, QGridLayout, QLabel, QComboBox
from qgis.PyQt.QtGui import QColor

from qgis.core import edit

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'geo_unit_colorizer_dockwidget_base.ui'))

def fstr(v):
    #if type(v) is QgsPointXY or type(v) is QgsPoint:
    #    return f'({v.x()}, {v.y()})'
    return str(v)

def info(*args):
    s = " ".join(map(fstr,args))
    QgsMessageLog.logMessage(s, level=Qgis.Info)

def set_layer_fill_color(layer, value, color):
    renderer = layer.renderer()
    categories = renderer.categories()
    for i in range(len(categories)):
        cat = categories[i]
        if value != cat.value():
            continue
        symbol = QgsFillSymbol()
        symbol_layer = symbol.symbolLayer(0)
        symbol_layer.setFillColor(QColor(color))
        symbol_layer.setStrokeWidth(0)
        #info('index', i, symbol)
        renderer.updateCategorySymbol(i, symbol)
        return True
    return False

def cmyk_to_rgb(c, m, y, k, cmyk, rgb_scale=255):
    #From https://graphicdesign.stackexchange.com/a/137902

    #Disclaimer: this is not "correct" in any way. The coefficients below are ones we made up. (In fact we made a spreadsheet of desired inputs and outputs and just solved for them) As others have commented conversion depends on the usage of the CMYK. However in some cases we have only the information ColorSpace = "DeviceCMYK", components = c,m,y,k. No other information is available and this needs to be rendered on screen. In which specific situation the following c# code works for us...

    # inputs are c,m,y,k components on a 0-1 scale
    # work with INVERSE of CMYK values, on a 0-255 scale
    C = 255 * (1 - c/cmyk)
    M = 255 * (1 - m/cmyk)
    Y = 255 * (1 - y/cmyk)
    K = 255 * (1 - k/cmyk)

    r = 80 + 0.5882 * C - 0.3529 * M - 0.1373 * Y + 0.00185 * C * M + 0.00046 * Y * C # no YM
    g = 66 - 0.1961 * C + 0.2745 * M - 0.0627 * Y + 0.00215 * C * M + 0.00008 * Y * C + 0.00062 * Y * M
    b = 86 - 0.3255 * C - 0.1569 * M + 0.1647 * Y + 0.00046 * C * M + 0.00123 * Y * C + 0.00215 * Y * M
    # (for non c# readers, the 'f' suffix on the numbers just indicates the precision of the data type to hold the value)
    r = r * K / 255
    g = g * K / 255
    b = b * K / 255
    # b,g,r are now the RGB components on a 0-255 scale, but will be out of bounds sometimes and need to be truncated to 0 and 255
    # Color RGB = Color.FromArgb(255, ((int)r).LimitTo(0, 255), ((int)g).LimitTo(0, 255), ((int)b).LimitTo(0, 255));
    ## LimitTo is an extension defined elsewhere - the usage should be obvious!
    r = min(255, max(0, r))
    g = min(255, max(0, g))
    b = min(255, max(0, b))
    return [r, g, b]

def cmyk_decode(val):
    pct = {
        '0': 0,
        "A": 8, "1": 13, "2": 20, "3": 30, "4": 40, "5": 50, "6": 60,
        "7": 70, "X": 100
    }
    cmyk = [pct[c] for c in val] # .split("").map(v => pct[v])
    return cmyk

class GeoUnitColorizerDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(GeoUnitColorizerDockWidget, self).__init__(parent)
        self.iface = iface
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.layer_selector = QComboBox()
        self.gridLayout.addWidget(self.layer_selector)
        self.unit_selector = QComboBox()
        self.gridLayout.addWidget(self.unit_selector)

        self.layer_selector.activated.connect(self.on_layer_change)
        
        # ScrollArea for the Geologic Colors
        scrollArea = QScrollArea()
        scrollArea.setWidgetResizable(True)
        scrollAreaWidgetContents = QWidget()
        gridLayout = QGridLayout(scrollAreaWidgetContents)
        scrollArea.setWidget(scrollAreaWidgetContents)
        self.gridLayout.addWidget(scrollArea)

        layers = []
        for layer in QgsProject.instance().mapLayers().values():
            info(layer.name(), layer.type())
            if layer.type() != Qgis.LayerType.Vector:
                continue
            if layer.geometryType() != Qgis.GeometryType.Polygon:
                continue
            info('add layer', layer.name())
            layers.append(layer)
        self.layer_names = [l.name() for l in layers]
        info(layers)
        info(self.layer_names)
        if len(self.layer_names) == 0:
            return

        self.layer_selector.addItems(self.layer_names)

        # Search for MapUnitPolys (it should be configurable, ....)
        mup = []
        mup_name = "MapUnitPolys"
        if mup_name not in self.layer_names:
            mup_name = self.layer_names[0]
        #mup = QgsProject.instance().mapLayersByName(mup_name)
        dmu = QgsProject.instance().mapLayersByName("DescriptionOfMapUnits")

        self.dmu = None
        if len(dmu) != 0:
            self.dmu = dmu[0]

        self.buttons_off = {}

        self.createGeologicColors(gridLayout)

        self.on_layer_change()

    def on_layer_change(self):
        #info('on layer change', self.layer_selector.currentText())
        mup_name = self.layer_selector.currentText()
        mup = QgsProject.instance().mapLayersByName(mup_name)
        if len(mup) == 0:
            return

        self.mup = mup[0]
        self.units = [cat.value() for cat in self.mup.renderer().categories() if cat.value() is not None]
        self.unit_selector.addItems(self.units)

        self.disableButtons()

    def disableButtons(self):
        for key, button in self.buttons_off.items():
            button.setEnabled(True)
            button.setToolTip("\n".join(button.toolTip().split("\n")[:2]))
            button.setText("")
        self.buttons_off = {}
        for cat in self.mup.renderer().categories():
            name = cat.value()
            color = cat.symbol().color()
            rgb = color.getRgb()
            rgb_hex = '#' + "".join([f"{v:02x}"for v in rgb[:3]])
            button = self.buttons.get(rgb_hex)
            if button:
                #info("disbale", rgb_hex)
                button.setEnabled(False)
                button.setToolTip(button.toolTip() + "\n" + name)
                button.setText(name)
                self.buttons_off[rgb_hex] = button
            #info("unit", rgb_hex)
        #info("buttons", list(self.buttons.keys())[:5])

    def refresh(self, layer):
        if self.iface.mapCanvas().isCachingEnabled():
            layer.triggerRepaint()
        else:
            self.iface.mapCanvas().refresh()
        self.iface.layerTreeView().refreshLayerSymbology(layer.id())

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def on_button_click(self, rgb_hex, rgb):
        unit = self.unit_selector.currentText()
        #info("Button click", rgb_hex, rgb, unit)
        if set_layer_fill_color(self.mup, unit, rgb_hex):
            self.refresh(self.mup)
        field_idx = self.dmu.fields().indexOf('AreaFillRGB')
        for feat in self.dmu.getFeatures():
            if unit == feat.attribute('MapUnit'):
                with edit(self.dmu):
                    self.dmu.changeAttributeValue(feat.id(), field_idx, rgb)
        self.disableButtons()

    def createGeologicColors(self, parent):
        file_path = Path(os.path.realpath(__file__)).parent / 'colors.json'
        self.colors = json.load(open(file_path,"r"))
        self.buttons = {}

        ncol = 1
        nrow = 1
        for div in self.colors:
            for name, rows in div.items():
                if name == "note":
                    continue
                label = QLabel(name)
                parent.addWidget(label, nrow, 1, 1, 10)
                nrow += 1
                for row in rows:
                    ncol = 2
                    for col in row:
                        if col == "":
                            ncol += 1
                            continue
                        cmyk = cmyk_decode(col)
                        rgb_comp = cmyk_to_rgb(cmyk[0], cmyk[1], cmyk[2], cmyk[3], 100)
                        rgb_comp = [math.floor(v) for v in rgb_comp]
                        rgb_hex = '#' + "".join([f"{v:02x}"for v in rgb_comp])
                        rgb_str = ','.join([str(v) for v in rgb_comp])
                        button = QPushButton("")
                        button.setMinimumWidth(20)
                        button.setMinimumHeight(18)
                        button.setToolTip(f"{col}\n{rgb_str}" )
                        font = button.font()
                        font.setPointSize(9)
                        button.setFont(font)
                        intensity = rgb_intensity(rgb_comp)
                        color = "white"
                        #if intensity > 187:
                        #    color = "black"
                        luminance = rgb_luminance(rgb_comp)
                        if luminance > 0.179:
                            color = 'black'
                        style = f'QPushButton {{background-color: {rgb_hex}; color: {color}; border: 2px solid {rgb_hex}; border-radius: 0.2em;}} '
                        # style += f'QPushButton:disabled {{ background-color: rgb(200,200,200); }} '
                        button.setStyleSheet(style)
                        parent.addWidget(button, nrow, ncol)
                        #info(rgb_hex, style)
                        button.clicked.connect(lambda state, x=rgb_hex, y=rgb_str : self.on_button_click(x,y))
                        #i += 1
                        self.buttons[rgb_hex] = button
                        ncol += 1
                    nrow += 1

def rgb_intensity(rgb):
    return rgb[0]*0.299 + rgb[1] * 0.587 + rgb[2] * 0.144
def rgb_luminance(rgb):
    z = [0,0,0]
    for i in range(3):
        c = rgb[i] / 255
        if c < 0.04045:
            c = c / 12.92
        else:
            c = ((c+0.055)/1.055)**2.4
        z[i] = c
    return z[0] * 0.2126 + z[1] * 0.7152 + z[2] * 0.0722
